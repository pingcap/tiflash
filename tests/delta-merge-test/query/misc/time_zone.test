# Copyright 2023 PingCAP, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Preparation.
=> DBGInvoke __enable_schema_sync_service('true')

=> DBGInvoke __drop_tidb_table(default, test)
=> drop table if exists default.test



# Data.
=> DBGInvoke __mock_tidb_table(default, test, 'col_1 MyDate, col_2 default \'asTiDBType|timestamp(5)\', col_3 MyDatetime')
=> DBGInvoke __refresh_mapped_table_schema(default, test)
=> DBGInvoke __put_region(4, 0, 100, default, test)
=> DBGInvoke __raft_insert_row(default, test, 4, 50, '2019-06-10', '2019-06-10 09:00:00', '2019-06-10 09:00:00')
=> DBGInvoke __raft_insert_row(default, test, 4, 51, '2019-06-11', '2019-06-11 07:00:00', '2019-06-11 09:00:00')
=> DBGInvoke __raft_insert_row(default, test, 4, 52, '2019-06-11', '2019-06-11 08:00:00', '2019-06-11 09:00:00')
=> DBGInvoke __raft_insert_row(default, test, 4, 53, '2019-06-12', '2019-06-11 08:00:00', '2019-06-11 09:00:00')
=> DBGInvoke __raft_insert_row(default, test, 4, 54, '1970-01-01', '1970-01-01 00:00:01', '1970-01-01 00:00:01')
=> DBGInvoke __raft_insert_row(default, test, 4, 55, '0000-00-00', '0000-00-00 00:00:00', '0000-00-00 00:00:00')

=> DBGInvoke dag('select * from default.test') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 09:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 00:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# use tz_offset, result is the same since cop will convert the timestamp value to utc timestamp when returing to tidb
=> DBGInvoke dag('select * from default.test',4,'encode_type:default,tz_offset:28800') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 09:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 00:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# test chunk encode
=> DBGInvoke dag('select * from default.test',4,'encode_type:chunk,tz_offset:28800') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 17:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 15:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 16:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 16:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 08:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# test chunk encode
=> DBGInvoke dag('select * from default.test',4,'encode_type:chunk,tz_offset:-28800') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 01:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-10 23:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 00:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 00:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1969-12-31 16:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# test default encode with negative timezone offset
=> DBGInvoke dag('select * from default.test',4,'encode_type:default,tz_offset:-28800') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 09:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 00:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# test chunk encode
=> DBGInvoke dag('select * from default.test',4,'encode_type:chunk,tz_name:America/Chicago') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 04:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 02:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 03:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 03:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1969-12-31 18:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# test default encode with negative timezone offset
=> DBGInvoke dag('select * from default.test',4,'encode_type:default,tz_name:America/Chicago') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 09:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 00:00:01.00000 │ 1970-01-01 00:00:01 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

=> DBGInvoke dag('select * from default.test where col_2 > col_3') 

=> DBGInvoke dag('select * from default.test where col_2 > col_3',4,'encode_type:default,tz_offset:28800') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-10 │ 2019-06-10 09:00:00.00000 │ 2019-06-10 09:00:00 │
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 1970-01-01 │ 1970-01-01 00:00:01.00000 │ 1970-01-01 00:00:01 │
└────────────┴───────────────────────────┴─────────────────────┘

=> DBGInvoke dag('select * from default.test where col_2 = col_3',4,'encode_type:default,tz_offset:3600') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-11 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 2019-06-12 │ 2019-06-11 08:00:00.00000 │ 2019-06-11 09:00:00 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

=> DBGInvoke dag('select * from default.test where col_2 = col_3',4,'encode_type:default,tz_offset:7200') 
┌──────col_1─┬─────────────────────col_2─┬───────────────col_3─┐
│ 2019-06-11 │ 2019-06-11 07:00:00.00000 │ 2019-06-11 09:00:00 │
│ 0000-00-00 │ 0000-00-00 00:00:00.00000 │ 0000-00-00 00:00:00 │
└────────────┴───────────────────────────┴─────────────────────┘

# tz_name overwrite tz_offset
=> DBGInvoke dag('select * from default.test where col_2 > col_3',4,'encode_type:default,tz_offset:28800,tz_name:UTC') 

# ts_col in group by clause
=> DBGInvoke dag('select count(1), col_2 from default.test where col_2 > \'2019-06-11 15:00:00\' group by col_2',4,'encode_type:default,tz_offset:28800') 
┌─count(1)─┬─────────────────────col_2─┐
│        2 │ 2019-06-11 08:00:00.00000 │
└──────────┴───────────────────────────┘

# ts_col in agg clause
=> DBGInvoke dag('select max(col_2), col_1 from default.test group by col_1',4,'encode_type:default,tz_offset:28800') 
┌──────────max(col_2)───────┬──────col_1─┐
│ 0000-00-00 00:00:00.00000 │ 0000-00-00 │
│ 2019-06-11 08:00:00.00000 │ 2019-06-12 │
│ 1970-01-01 00:00:01.00000 │ 1970-01-01 │
│ 2019-06-11 08:00:00.00000 │ 2019-06-11 │
│ 2019-06-10 09:00:00.00000 │ 2019-06-10 │
└───────────────────────────┴────────────┘

# ts_col in agg clause for chunk encode
=> DBGInvoke dag('select max(col_2), col_1 from default.test group by col_1',4,'encode_type:chunk,tz_offset:28800') 
┌──────────max(col_2)───────┬──────col_1─┐
│ 0000-00-00 00:00:00.00000 │ 0000-00-00 │
│ 2019-06-11 16:00:00.00000 │ 2019-06-12 │
│ 1970-01-01 08:00:01.00000 │ 1970-01-01 │
│ 2019-06-11 16:00:00.00000 │ 2019-06-11 │
│ 2019-06-10 17:00:00.00000 │ 2019-06-10 │
└───────────────────────────┴────────────┘

# Clean up.
=> DBGInvoke __drop_tidb_table(default, test)
=> drop table if exists default.test
