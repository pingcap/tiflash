#include <random>

#include <gperftools/malloc_extension.h>

#include <DataStreams/IBlockOutputStream.h>
#include <Storages/StorageDeltaMerge.h>
#include <Storages/StorageFactory.h>
#include <Storages/StorageTinyLog.h>

#include <Common/typeid_cast.h>
#include <Core/Defines.h>
#include <Interpreters/Context.h>
#include <Parsers/ASTCreateQuery.h>
#include <Parsers/ASTExpressionList.h>
#include <Parsers/ASTFunction.h>
#include <Parsers/ASTIdentifier.h>
#include <Parsers/ASTInsertQuery.h>
#include <Parsers/ASTSelectQuery.h>


namespace DB
{
using namespace DM;

constexpr bool TEST_SPLIT = false;

StorageDeltaMerge::StorageDeltaMerge(const std::string & path_,
    const std::string & name_,
    const ColumnsDescription & columns_,
    const ASTPtr & primary_expr_ast_,
    Context & global_context_)
    : IManageableStorage{columns_},
      path(path_ + "/" + name_),
      name(name_),
      global_context(global_context_),
      log(&Logger::get("StorageDeltaMerge"))
{
    if (primary_expr_ast_->children.empty())
        throw Exception("No primary key");

    std::unordered_set<String> pks;
    for (size_t i = 0; i < primary_expr_ast_->children.size(); ++i)
    {
        auto col_name = primary_expr_ast_->children[i]->getColumnName();
        pks.emplace(col_name);
        pk_column_names.emplace_back(col_name);
    }

    ColumnsDescription new_columns(columns_.ordinary, columns_.materialized, columns_.materialized, columns_.defaults);

    size_t pks_combined_bytes = 0;
    auto all_columns = getColumns().getAllPhysical();
    size_t index = 0;
    for (auto & col : all_columns)
    {
        ColumnDefine column_define;
        column_define.name = col.name;
        column_define.type = col.type;
        column_define.id = index++;

        if (pks.count(col.name))
        {
            if (!col.type->isValueRepresentedByInteger())
                throw Exception("pk column " + col.name + " is not representable by integer");

            pks_combined_bytes += col.type->getSizeOfValueInMemory();
            if (pks_combined_bytes > sizeof(Handle))
                throw Exception("pk columns exceeds size limit :" + DB::toString(sizeof(Handle)));

            if (pks.size() == 1)
                handle_column_define = column_define;
        }

        table_column_defines.push_back(column_define);
        addColumn(header, column_define.id, col.name, col.type, col.type->createColumn());
    }

    hidden_columns.emplace_back(VERSION_COLUMN_NAME);
    hidden_columns.emplace_back(TAG_COLUMN_NAME);
    new_columns.materialized.emplace_back(VERSION_COLUMN_NAME, VERSION_COLUMN_TYPE);
    new_columns.materialized.emplace_back(TAG_COLUMN_NAME, TAG_COLUMN_TYPE);

    if (pks.size() > 1)
    {
        handle_column_define.id = EXTRA_HANDLE_COLUMN_ID;
        handle_column_define.name = EXTRA_HANDLE_COLUMN_NAME;
        handle_column_define.type = EXTRA_HANDLE_COLUMN_TYPE;

        hidden_columns.emplace_back(EXTRA_HANDLE_COLUMN_NAME);
        new_columns.materialized.emplace_back(EXTRA_HANDLE_COLUMN_NAME, EXTRA_HANDLE_COLUMN_TYPE);
    }

    setColumns(new_columns);

    store = std::make_shared<DeltaMergeStore>(
        global_context, path, name, table_column_defines, handle_column_define, DeltaMergeStore::Settings());
}

void StorageDeltaMerge::drop()
{
    // Reclaim memory.
    MallocExtension::instance()->ReleaseFreeMemory();
}

Block StorageDeltaMerge::buildInsertBlock(bool is_import, const Block & old_block)
{
    Block block = old_block;

    if (!is_import)
    {
        // Remove the default columns generated by InterpreterInsertQuery
        if (block.has(EXTRA_HANDLE_COLUMN_NAME))
            block.erase(EXTRA_HANDLE_COLUMN_NAME);
        if (block.has(VERSION_COLUMN_NAME))
            block.erase(VERSION_COLUMN_NAME);
        if (block.has(TAG_COLUMN_NAME))
            block.erase(TAG_COLUMN_NAME);
    }

    const size_t rows = block.rows();
    if (!block.has(handle_column_define.name))
    {
        // put handle column.

        auto handle_column = handle_column_define.type->createColumn();
        auto & handle_data = typeid_cast<ColumnVector<Handle> &>(*handle_column).getData();
        handle_data.resize(rows);

        size_t pk_column_count = pk_column_names.size();
        Columns pk_columns;
        std::vector<DataTypePtr> pk_column_types;
        for (auto & n : pk_column_names)
        {
            auto & col = block.getByName(n);
            pk_columns.push_back(col.column);
            pk_column_types.push_back(col.type);
        }

        for (size_t c = 0; c < pk_column_count; ++c)
        {
            appendIntoHandleColumn(handle_data, pk_column_types[c], pk_columns[c]);
        }

        addColumn(block, EXTRA_HANDLE_COLUMN_ID, EXTRA_HANDLE_COLUMN_NAME, EXTRA_HANDLE_COLUMN_TYPE, std::move(handle_column));
    }

    // add version column
    if (!block.has(VERSION_COLUMN_NAME))
    {
        auto column = VERSION_COLUMN_TYPE->createColumn();
        auto & column_data = typeid_cast<ColumnVector<UInt64> &>(*column).getData();
        column_data.resize(rows);
        for (size_t i = 0; i < rows; ++i)
        {
            column_data[i] = next_version++;
        }

        addColumn(block, VERSION_COLUMN_ID, VERSION_COLUMN_NAME, VERSION_COLUMN_TYPE, std::move(column));
    }

    // add tag column (upsert / delete)
    if (!block.has(TAG_COLUMN_NAME))
    {
        auto column = TAG_COLUMN_TYPE->createColumn();
        auto & column_data = typeid_cast<ColumnVector<UInt8> &>(*column).getData();
        column_data.resize(rows);
        for (size_t i = 0; i < rows; ++i)
        {
            column_data[i] = 0;
        }

        addColumn(block, TAG_COLUMN_ID, TAG_COLUMN_NAME, TAG_COLUMN_TYPE, std::move(column));
    }

    // Set the real column id.
    for (auto & col : block)
    {
        if (col.name != VERSION_COLUMN_NAME && col.name != TAG_COLUMN_NAME && col.name != EXTRA_HANDLE_COLUMN_NAME)
            col.column_id = header.getByName(col.name).column_id;
    }

    return block;
}

using BlockDecorator = std::function<Block(const Block &)>;
class DMBlockOutputStream : public IBlockOutputStream
{
public:
    DMBlockOutputStream(const DeltaMergeStorePtr & store_,
        const Block & header_,
        const BlockDecorator & decorator_,
        const Context & db_context_,
        const Settings & db_settings_)
        : store(store_), header(header_), decorator(decorator_), db_context(db_context_), db_settings(db_settings_)
    {}

    Block getHeader() const override { return header; }

    void write(const Block & block) override { store->write(db_context, db_settings, decorator(block)); }

private:
    DeltaMergeStorePtr store;
    Block header;
    BlockDecorator decorator;
    const Context & db_context;
    const Settings & db_settings;
};

BlockOutputStreamPtr StorageDeltaMerge::write(const ASTPtr & query, const Settings & settings)
{
    auto & insert_query = typeid_cast<const ASTInsertQuery &>(*query);
    BlockDecorator decorator = std::bind(&StorageDeltaMerge::buildInsertBlock, this, insert_query.is_import, std::placeholders::_1);
    return std::make_shared<DMBlockOutputStream>(store, header, decorator, global_context, settings);
}


BlockInputStreams StorageDeltaMerge::read( //
    const Names & column_names,
    const SelectQueryInfo & query_info,
    const Context & context,
    QueryProcessingStage::Enum & /*processed_stage*/,
    size_t max_block_size,
    unsigned num_streams)
{
    ColumnDefines to_read;
    for (auto & n : column_names)
    {
        ColumnDefine col_define;
        if (n == EXTRA_HANDLE_COLUMN_NAME)
            col_define = handle_column_define;
        else if (n == VERSION_COLUMN_NAME)
            col_define = VERSION_COLUMN_DEFINE;
        else if (n == TAG_COLUMN_NAME)
            col_define = TAG_COLUMN_DEFINE;
        else
        {
            auto & column = header.getByName(n);
            col_define.name = column.name;
            col_define.id = column.column_id;
            col_define.type = column.type;
        }
        to_read.push_back(col_define);
    }


    HandleRanges ranges;
    if (TEST_SPLIT)
    {
        /// TODO Those code is used to test range read, should be removed later

        size_t rate_base = 1000000;
        Handle start = N_INF_HANDLE;
        {
            auto streams = store->readRaw(context, context.getSettingsRef(), {store->getHandle()}, 1);
            auto stream = streams[0];
            stream->readPrefix();

            while (true)
            {
                Block block = stream->read();
                if (!block)
                    break;
                auto & handle_data = DB::DM::getColumnVectorData<Handle>(block, 0);
                for (size_t i = 0; i < handle_data.size(); ++i)
                {
                    if ((std::abs(random()) % rate_base) == 0)
                    {
                        ranges.emplace_back(start, handle_data[i]);
                        start = handle_data[i];
                    }
                }
            }

            ranges.emplace_back(start, DB::DM::P_INF_HANDLE);

            stream->readSuffix();
        }

        LOG_DEBUG(log, "Random split ranges: " + DB::toString(ranges.size()));

        Handle prev = N_INF_HANDLE;
        for (auto & r : ranges)
        {
            if (r.start != prev)
                LOG_DEBUG(log, "illegal, expected " + DB::toString(prev) + ". got " + DB::toString(r.start));

            prev = r.end;

            if (r.start == r.end)
                LOG_DEBUG(log, "range start and end are identical");
        }
    }
    else
    {
        ranges.emplace_back(DB::DM::HandleRange::newAll());
    }

    const ASTSelectQuery & select_query = typeid_cast<const ASTSelectQuery &>(*query_info.query);
    if (select_query.raw_for_mutable)
        return store->readRaw(context, context.getSettingsRef(), to_read, num_streams);
    else
        return store->read(
            context, context.getSettingsRef(), to_read, ranges, num_streams, std::numeric_limits<UInt64>::max(), max_block_size);
}

void StorageDeltaMerge::check(const Context & context) { store->check(context, context.getSettingsRef()); }

namespace ErrorCodes
{
extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
}

static ASTPtr extractKeyExpressionList(IAST & node)
{
    const ASTFunction * expr_func = typeid_cast<const ASTFunction *>(&node);

    if (expr_func && expr_func->name == "tuple")
    {
        /// Primary key is specified in tuple.
        return expr_func->children.at(0);
    }
    else
    {
        /// Primary key consists of one column.
        auto res = std::make_shared<ASTExpressionList>();
        res->children.push_back(node.ptr());
        return res;
    }
}

void registerStorageDeltaMerge(StorageFactory & factory)
{
    factory.registerStorage("DeltaMerge", [](const StorageFactory::Arguments & args) {
        if (args.engine_args.size() > 1)
            throw Exception("Engine DeltaMerge expects only one parameter. e.g. engine = DeltaMerge((a, b))");
        if (args.engine_args.size() < 1)
            throw Exception(
                "Engine DeltaMerge needs primary key. e.g. engine = DeltaMerge((a, b))", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
        ASTPtr primary_expr_list = extractKeyExpressionList(*args.engine_args[0]);
        return StorageDeltaMerge::create(args.data_path, args.table_name, args.columns, primary_expr_list, args.context);
    });
}

} // namespace DB