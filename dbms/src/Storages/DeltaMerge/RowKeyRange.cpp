// Copyright 2023 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <Common/RedactHelpers.h>
#include <Storages/DeltaMerge/RowKeyRange.h>

namespace DB::DM
{
const Int64 int_handle_min = std::numeric_limits<HandleID>::min();
const Int64 int_handle_max = std::numeric_limits<HandleID>::max();

String getIntHandleMinKey()
{
    WriteBufferFromOwnString ss;
    DB::EncodeInt64(int_handle_min, ss);
    return ss.releaseStr();
}

String getIntHandleMaxKey()
{
    WriteBufferFromOwnString ss;
    DB::EncodeInt64(int_handle_max, ss);
    ss.write('\0');
    return ss.releaseStr();
}

const RowKeyValue RowKeyValue::INT_HANDLE_MIN_KEY
    = RowKeyValue(false, std::make_shared<String>(getIntHandleMinKey()), int_handle_min);
const RowKeyValue RowKeyValue::INT_HANDLE_MAX_KEY
    = RowKeyValue(false, std::make_shared<String>(getIntHandleMaxKey()), int_handle_max);
const RowKeyValue RowKeyValue::COMMON_HANDLE_MIN_KEY
    = RowKeyValue(true, std::make_shared<String>(1, TiDB::CodecFlag::CodecFlagBytes), 0);
const RowKeyValue RowKeyValue::COMMON_HANDLE_MAX_KEY
    = RowKeyValue(true, std::make_shared<String>(1, TiDB::CodecFlag::CodecFlagMax), 0);
const RowKeyValue RowKeyValue::EMPTY_STRING_KEY = RowKeyValue(true, std::make_shared<String>(""), 0);

std::pair<RowKeyValue, std::string_view> RowKeyValue::fromHandleWithSuffix(
    bool is_common_handle_,
    const HandleValuePtr value_)
{
    if (is_common_handle_)
    {
        RowKeyValue rowkey_value(is_common_handle_, value_, 0);
        return {rowkey_value, std::string_view{nullptr, 0}};
    }

    assert(!is_common_handle_);
    // According to the tidb encoding rule, the int handle must be larger or equal to 8 bytes.
    RUNTIME_CHECK_MSG(
        value_->size() >= sizeof(Int64),
        "Meet illegal int handle size less than expected, value_size={} value={}",
        value_->size(),
        Redact::keyToHexString(value_->data(), value_->size()));

    size_t cursor = 0;
    Int64 int_value = DB::DecodeInt64(cursor, *value_);
    if (unlikely(value_->size() > sizeof(UInt64)))
    {
        // For int type handle, the standard key encoding format should be t{table_id}_r{handle_value}.
        // But TiKV may generate region range keys which are not strictly following the standard format.
        // More concretely, the key may be t{table_id}_r{handle_value}{any_suffix}.
        // We need to adapt the key to the standard format.
        // For example, the key may be t100_r1000 + '0x00', '0x01' or any other suffix, we need to adapt it to t100_r1001.
        // This is ok, because
        //  1) if the key is the start range, then [t100_r1000 + 0x00, xxx) has the same semantics with [t100_r1001, xxx)
        //  2) if the key is the end range, then [xxx, t100_r1000 + 0x00) also has the same semantics with [xxx, t100_r1001)
        //
        // Note if the `int_value` is Int64::max_value,
        // it is a value generated by tiflash itself to means +inf()(which is RowKeyValue::INT_HANDLE_MAX_KEY).
        // So we can just ignore it.
        if (int_value < std::numeric_limits<Int64>::max())
        {
            int_value = int_value + 1;
            WriteBufferFromOwnString ss;
            DB::EncodeInt64(int_value, ss);
            HandleValuePtr fixed_value = std::make_shared<String>(ss.releaseStr());
            return {
                RowKeyValue(is_common_handle_, fixed_value, int_value),
                std::string_view{value_->data() + sizeof(int_value), value_->size() - sizeof(int_value)},
            };
        }
        else
        {
            // keep the int_value unchanged if it is RowKeyValue::INT_HANDLE_MAX_KEY
        }
    }
    return {RowKeyValue(is_common_handle_, value_, int_value), std::string_view{nullptr, 0}};
}

RowKeyValue RowKeyValueRef::toRowKeyValue() const
{
    if (data == nullptr)
    {
        WriteBufferFromOwnString ss;
        DB::EncodeInt64(int_value, ss);
        return RowKeyValue(is_common_handle, std::make_shared<String>(ss.releaseStr()), int_value);
    }
    else
    {
        return RowKeyValue(is_common_handle, std::make_shared<String>(data, size), int_value);
    }
}

std::unordered_map<KeyspaceTableID, RowKeyRange::TableRangeMinMax, boost::hash<KeyspaceTableID>>
    RowKeyRange::table_min_max_data;
std::shared_mutex RowKeyRange::table_mutex;

const RowKeyRange::TableRangeMinMax & RowKeyRange::getTableMinMaxData(
    KeyspaceID keyspace_id,
    TableID table_id,
    bool is_common_handle)
{
    auto keyspace_table_id = KeyspaceTableID{keyspace_id, table_id};
    {
        std::shared_lock lock(table_mutex);
        if (auto it = table_min_max_data.find(keyspace_table_id); it != table_min_max_data.end())
            return it->second;
    }
    std::unique_lock lock(table_mutex);
    return table_min_max_data.try_emplace(keyspace_table_id, keyspace_id, table_id, is_common_handle).first->second;
}

template <bool enable_redact, bool right_open = true>
inline String rangeToString(const RowKeyValue & start, const RowKeyValue & end)
{
    String s = "[";
    if constexpr (enable_redact)
        s += start.toDebugString() + "," + end.toDebugString();
    else
        s += start.toString() + "," + end.toString();

    if constexpr (right_open)
        s += ")";
    else
        s += "]";
    return s;
}

template <bool enable_redact>
inline String rangeToString(const RowKeyRange & range)
{
    return rangeToString<enable_redact, true>(range.start, range.end);
}

String RowKeyValueRef::toDebugString() const
{
    if (is_common_handle)
        return Redact::keyToDebugString(data, size);
    return Redact::handleToDebugString(int_value);
}

String RowKeyValue::toString() const
{
    if (is_common_handle)
        return Redact::keyToHexString(value->data(), value->size());
    return DB::toString(int_value);
}

String RowKeyValue::toDebugString() const
{
    if (is_common_handle)
        return Redact::keyToDebugString(value->data(), value->size());
    return Redact::handleToDebugString(int_value);
}

String RowKeyRange::toDebugString() const
{
    return rangeToString</*enable_redact*/ true>(*this);
}

String RowKeyRange::toString() const
{
    return rangeToString</*enable_redact*/ false>(*this);
}

} // namespace DB::DM
