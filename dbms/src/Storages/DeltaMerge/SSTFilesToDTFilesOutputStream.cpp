#include <Common/TiFlashMetrics.h>
#include <Interpreters/Context.h>
#include <Poco/File.h>
#include <RaftStoreProxyFFI/ColumnFamily.h>
#include <Storages/DeltaMerge/DeltaMergeStore.h>
#include <Storages/DeltaMerge/File/DMFile.h>
#include <Storages/DeltaMerge/File/DMFileBlockOutputStream.h>
#include <Storages/DeltaMerge/SSTFilesToDTFilesOutputStream.h>
#include <Storages/StorageDeltaMerge.h>
#include <Storages/Transaction/ProxyFFI.h>
#include <Storages/Transaction/Region.h>
#include <Storages/Transaction/SSTReader.h>
#include <Storages/Transaction/TMTContext.h>
#include <common/logger_useful.h>

namespace DB
{

namespace ErrorCodes
{
extern const int ILLFORMAT_RAFT_ROW;
} // namespace ErrorCodes

std::tuple<Block, std::shared_ptr<StorageDeltaMerge>, DM::ColumnDefinesPtr> //
GenRegionBlockDatawithSchema(const RegionPtr & region, TMTContext & tmt);

namespace DM
{

SSTFilesToDTFilesOutputStream::SSTFilesToDTFilesOutputStream( //
    BoundedSSTFilesToBlockInputStreamPtr child_,
    TiDB::SnapshotApplyMethod            method_,
    FileConvertJobType                   job_type_,
    TMTContext &                         tmt_)
    : child(child_), //
      method(method_),
      job_type(job_type_),
      tmt(tmt_),
      log(&Poco::Logger::get("SSTFilesToDTFilesOutputStream"))
{
}

SSTFilesToDTFilesOutputStream::~SSTFilesToDTFilesOutputStream() = default;

void SSTFilesToDTFilesOutputStream::writePrefix()
{
    child->readPrefix();

    commit_rows = 0;
    watch.start();
}

void SSTFilesToDTFilesOutputStream::writeSuffix()
{
    child->readSuffix();

    finishCurrDTFileStream();

    auto & ctx     = tmt.getContext();
    auto   metrics = ctx.getTiFlashMetrics();
    if (job_type == FileConvertJobType::ApplySnapshot)
    {
        GET_METRIC(metrics, tiflash_raft_command_duration_seconds, type_apply_snapshot_predecode).Observe(watch.elapsedSeconds());
        // Note that number of keys in different cf will be aggregated into one metrics
        GET_METRIC(metrics, tiflash_raft_process_keys, type_apply_snapshot).Increment(child->getProcessKeys());
    }
    else
    {
        // Note that number of keys in different cf will be aggregated into one metrics
        GET_METRIC(metrics, tiflash_raft_process_keys, type_ingest_sst).Increment(child->getProcessKeys());
    }
    LOG_INFO(log,
             "Pre-handle snapshot " << child->getRegion()->toString(true) << " to " << ingest_files.size() << " DTFiles, cost "
                                    << watch.elapsedMilliseconds() << "ms [rows=" << commit_rows << "]");
}

void SSTFilesToDTFilesOutputStream::write()
{
    while (true)
    {
        Block block = child->read();
        if (!block)
            break;
        if (unlikely(block.rows() == 0))
            continue;

        auto [storage, schema_snap] = child->ingestingInfo();
        ingest_storage              = storage;

        if (dt_stream == nullptr || SSTFilesToBlockInputStream::needUpdateSchema(cur_schema, schema_snap))
        {
            // Close previous DTFile and output stream before creating new DTFile for new schema
            finishCurrDTFileStream();

            // Generate a DMFilePtr and its DMFileBlockOutputStream if not exists
            bool single_file_mode = false;
            switch (method)
            {
            case TiDB::SnapshotApplyMethod::DTFile_Directory:
                single_file_mode = false;
                break;
            case TiDB::SnapshotApplyMethod::DTFile_Single:
                single_file_mode = true;
                break;
            default:
                break;
            }

            // The parent_path and file_id are generated by the storage.
            auto [parent_path, file_id] = ingest_storage->getStore()->preAllocateIngestFile();
            if (parent_path.empty())
            {
                // Can no allocate path and id for storing DTFiles (the storage may be dropped / shutdown),
                break;
            }
            auto dt_file = DMFile::create(file_id, parent_path, single_file_mode);
            LOG_INFO(log, "Create file for snapshot data [file=" << dt_file->path() << "] [single_file_mode=" << single_file_mode << "]");
            cur_schema = schema_snap;
            dt_stream  = std::make_unique<DMFileBlockOutputStream>(tmt.getContext(), dt_file, *cur_schema, /*need_rate_limit=*/false);
            dt_stream->writePrefix();
            ingest_files.emplace_back(dt_file);
        }

        {
            // Check whether rows are sorted by handle & version in ascending order.
            SortDescription sort;
            sort.emplace_back(MutableSupport::tidb_pk_column_name, 1, 0);
            sort.emplace_back(MutableSupport::version_column_name, 1, 0);
            if (block.rows() > 1 && !isAlreadySorted(block, sort))
                throw Exception("The block decoded from SSTFile is not sorted by primary key and version [region="
                                + child->getRegion()->toString(true) + "]");
        }

        // Write block to the output stream
        dt_stream->write(block, /*not_clean_rows=*/1);

        commit_rows += block.rows();
    }
}

void SSTFilesToDTFilesOutputStream::finishCurrDTFileStream()
{
    if (dt_stream == nullptr)
        return;

    assert(dt_stream != nullptr);

    dt_stream->writeSuffix();
    auto dt_file = dt_stream->getFile();
    // The DTFile should not be able to gc until it is ingested.
    assert(!dt_file->canGC());
    // Add the DTFile to StoragePathPool so that we can restore it later
    ingest_storage->getStore()->preIngestFile(dt_file->parentPath(), dt_file->fileId(), dt_file->getBytesOnDisk());
    dt_stream.reset();
}

PageIds SSTFilesToDTFilesOutputStream::ingestIds() const
{
    PageIds ids;
    for (const auto & file : ingest_files)
    {
        ids.emplace_back(file->fileId());
    }
    return ids;
}

void SSTFilesToDTFilesOutputStream::cancel()
{
    // Try a lightweight cleanup the file generated by this stream (marking them able to be GC-ed).
    for (auto & file : ingest_files)
    {
        try
        {
            file->enableGC();
        }
        catch (...)
        {
            tryLogCurrentException(log, "ignore exception while canceling SST files to DeltaTree files stream [file=" + file->path() + "]");
        }
    }
}

} // namespace DM
} // namespace DB
