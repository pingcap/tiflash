#pragma once

#include <optional>

#include <IO/CompressedStream.h>
#include <IO/ReadHelpers.h>
#include <IO/WriteHelpers.h>

#include <DataTypes/DataTypeFactory.h>
#include <DataTypes/IDataType.h>
#include <Storages/DeltaMerge/DMContext.h>
#include <Storages/DeltaMerge/DeltaMergeDefines.h>
#include <Storages/DeltaMerge/Index/RSIndex.h>
#include <Storages/DeltaMerge/Range.h>
#include <Storages/Page/PageStorage.h>


namespace DB
{
namespace DM
{
static constexpr size_t PACK_SERIALIZE_BUFFER_SIZE = 65536;


struct ColumnMeta
{
    ColId          col_id;
    PageId         page_id;
    UInt32         rows;
    UInt64         bytes;
    DataTypePtr    type;
//    MinMaxIndexPtr minmax{};
};
using ColumnMetas = std::vector<ColumnMeta>;

static std::atomic<UInt64> PACK_MAX_PACK_ID = 0;

class Pack
{
public:
    // Binary version of pack
    using Version = UInt32;
    static const Version CURRENT_VERSION;

public:
    using ColumnMetaMap = std::unordered_map<ColId, ColumnMeta>;

    Pack(Handle handle_first_, Handle handle_last_)
        : pack_id(++PACK_MAX_PACK_ID), handle_start(handle_first_), handle_end(handle_last_), is_delete_range(false)
    {
    }
    explicit Pack(const HandleRange & delete_range)
        : pack_id(++PACK_MAX_PACK_ID), handle_start(delete_range.start), handle_end(delete_range.end), is_delete_range(true)
    {
    }

    UInt64      id() const { return pack_id; }
    bool        isDeleteRange() const { return is_delete_range; }
    HandleRange getDeleteRange() const
    {
        if (!is_delete_range)
            throw Exception("Not a delete range");
        return {handle_start, handle_end};
    }

    // TODO: remove this method, it can no longer represents the min, max of this pack.
    // A pack may be generated by serveral packs, by simply append together, without sorting.
    HandlePair getHandleFirstLast() const
    {
        if (is_delete_range)
            throw Exception("It is a delete range");
        return {handle_start, handle_end};
    }

    size_t getRows() const { return rows; }

    UInt64 getBytes() const
    {
        UInt64 bytes = 0;
        for (const auto & p : columns)
            bytes += p.second.bytes;
        return bytes;
    }

    bool hasColumn(ColId col_id) const { return columns.count(col_id) > 0; }

    const ColumnMeta & getColumn(ColId col_id) const
    {
        auto it = columns.find(col_id);
        if (unlikely(it == columns.end()))
            throw Exception("Column with id" + DB::toString(col_id) + " not found");
        return it->second;
    }

    const ColumnMeta * tryGetColumn(ColId col_id) const
    {
        auto it = columns.find(col_id);
        if (unlikely(it == columns.end()))
            return nullptr;
        return &it->second;
    }

    const ColumnMetaMap & getMetas() const { return columns; }

    void insert(const ColumnMeta & c)
    {
        if (isDeleteRange())
            throw Exception("Insert column into delete range pack is not allowed");
        columns[c.col_id] = c;
        if (rows != 0 && rows != c.rows)
            throw Exception("Rows not match");
        else
            rows = c.rows;
    }

    void         serialize(WriteBuffer & buf) const;
    static Pack deserialize(ReadBuffer & buf);

    String info() const
    {
        if (likely(!is_delete_range))
            return "Pack[" + DB::toString(handle_start) + "," + DB::toString(handle_end) + "]";
        else
            return "DeleteRange[" + DB::toString(handle_start) + "," + DB::toString(handle_end) + ")";
    }

private:
    // pack_id is a in-memory concept. It is mainly used to determine whether an operation is legal or not before apply.
    UInt64 pack_id;

    Handle        handle_start;
    Handle        handle_end;
    bool          is_delete_range;
    ColumnMetaMap columns;
    size_t        rows = 0;
};

// TODO: use list instead of vector, so that DiskValueSpace won't need to do copy during Segment#getReadSnapshot.
using Packs    = std::vector<Pack>;
using GenPageId = std::function<PageId()>;

Pack  createRefPack(const Pack & pack, const GenPageId & gen_data_page_id, WriteBatch & wb);
Packs createRefPacks(const Packs & packs, const GenPageId & gen_data_page_id, WriteBatch & wb);

void serializePacks(WriteBuffer &          buf,
                     Packs::const_iterator begin,
                     Packs::const_iterator end,
                     const Pack *          extra1 = nullptr,
                     const Pack *          extra2 = nullptr);
void serializePacks(WriteBuffer &          buf, //
                     Packs::const_iterator begin,
                     Packs::const_iterator end,
                     const Packs &         extr_packs);

Packs deserializePacks(ReadBuffer & buf);

Pack preparePackDataWrite(const DMContext & dm_context, const GenPageId & gen_data_page_id, WriteBatch & wb, const Block & block);

/**
 * Read `pack`'s columns from `storage` and append the `pack`'s data range
 * [`rows_offset`, `rows_offset`+`rows_limit`) to `columns`.
 *
 * Note that after ddl, the data type between `pack.columns` and `column_defines` maybe different,
 * we do a cast according to `column_defines` before append to `columns`.
 *
 * @param columns           The columns to append data.
 * @param column_defines    The DataType, column-id of `columns`.
 * @param pack             Info about pack to read. e.g. PageId in `storage`, DataType for reading.
 * @param page_reader       Where the serialized data stored in.
 * @param rows_offset
 * @param rows_limit
 */
void readPackData(MutableColumns &      columns,
                   const ColumnDefines & column_defines,
                   const Pack &         pack,
                   const PageReader &    page_reader,
                   size_t                rows_offset,
                   size_t                rows_limit);


Block readPack(const Pack & pack, const ColumnDefines & read_column_defines, const PageReader & page_reader);

/**
 * Cast `disk_col` from `disk_type` according to `read_define`, and append data
 * [`rows_offset`, `rows_offset`+`rows_limit`) to `memory_col`
 *
 * @param disk_type
 * @param disk_col
 * @param read_define
 * @param memory_col
 * @param rows_offset
 * @param rows_limit
 */
void castColumnAccordingToColumnDefine(const DataTypePtr &  disk_type,
                                       const ColumnPtr &    disk_col,
                                       const ColumnDefine & read_define,
                                       MutableColumnPtr     memory_col,
                                       size_t               rows_offset,
                                       size_t               rows_limit);


} // namespace DM
} // namespace DB
